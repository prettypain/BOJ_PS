'''
"""
문제 자체는 로컬에서 에라스토테네스의 체로 100000000까지 구하고
거기서 구한 모든 소수를 조건에 맞는 값만 모아서 코드에 저장후
제출상에서는 이미 구한값에 접근만 하면 정답이 나오는 풀이로 작성했다.

사실상 n 범위가 작아서 로컬에서 정답을 구한뒤 답만 보낸것과 같다.
꼼수 느낌이......
"""
def check(target):
    for idx in range(len(target)-1, 0, -1):
        if not lst[int(target[:idx])]: return False

    return len(target)
t = 100000000
lst = list(range(t))
lst[1] = 0
for i in range(2, int(t**0.5)+1):
    if lst[i] == 0: continue
    for j in range(i+i, t, i): lst[j] = 0
dic = {i:[]  for i in range(1, 9)}

for i in list(filter(lambda x : x!=0, lst)):
    l = check(str(i))
    if l: dic[l].append(i)
'''
dic = {1: [2, 3, 5, 7], 2: [23, 29, 31, 37, 53, 59, 71, 73, 79], 3: [233, 239, 293, 311, 313, 317, 373, 379, 593, 599, 719, 733, 739, 797], 4: [2333, 2339, 2393, 2399, 2939, 3119, 3137, 3733, 3739, 3793, 3797, 5939, 7193, 7331, 7333, 7393], 5: [23333, 23339, 23399, 23993, 29399, 31193, 31379, 37337, 37339, 37397, 59393, 59399, 71933, 73331, 73939], 6: [233993, 239933, 293999, 373379, 373393, 593933, 593993, 719333, 739391, 739393, 739397, 739399], 7: [2339933, 2399333, 2939999, 3733799, 5939333, 7393913, 7393931, 7393933], 8: [23399339, 29399999, 37337999, 59393339, 73939133]}

print(*dic[int(input())], sep="\n")