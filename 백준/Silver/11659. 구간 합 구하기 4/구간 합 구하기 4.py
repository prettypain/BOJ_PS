'''
테케 0%에서 테이터를 얼마나 줬으면 sys.stdin.readline이나 pyyp를 안쓰고 통과를 못하냐 ㅋㅋㅋ
구간합을 구하는 문제는 대표적으로 prefix sum(누적합)알고리즘을 사용한다.
약간 누적합 배열 만들때 느낌이 피보나치 바텀업 방식이랑 굉장히 유사하다.

일단 lst = [0]을 만들고
5 3
5 4 3 2 1를 입력받았다고 가정하다.
누적합은 내 위치가 i라고 하면 lst[i] = lst[i] + lst[i-1]이 성립한다(단 i>=1)

피보나치 수열도
fibo(n) = fibo(n-1) + fibo(n-2)가 성립 한다.(단 n>=2 이상일 때 성립한다)
lst[i] = lst[i-1] + lst[i-2]

최종적으로 누적합 배열이 만들어 지는 과정이다. (5 4 3 2 1입력일 때)
lst[1] = 0 + 5
lst[2] = (0 + 5) + 4
lst[3] = (0 + 5 + 4) + 3
lst[4] = (0 + 5 + 4 + 3) + 2
lst[5] = (0 + 5 + 4 + 3 + 2) + 1
즉
lst[1] = lst[0] + lst[1] (i : 0~1 까지의 합)
lst[2] = lst[1] + lst[2] (i : 0~2 까지의 합)
lst[3] = lst[2] + lst[3] (i : 0~3 까지의 합)
lst[4] = lst[3] + lst[4] (i : 0~4 까지의 합)
lst[5] = lst[4] + lst[5] (i : 0~5 까지의 합)

lst = [0, 5, 9, 12, 14, 15]

그리고 1~3번째 까지의 합을 구하는 방법은 다음과 같다.
i, j번째 까지의 합을 구한다고 가정하면
i~j까지의 합 : lst[j] - lst[i]
예를 들어
1 3이 입력되었다면
lst[3] - lst[1-1] = 12 - 0 = 12
가 된다.
lst[3]은 {0, 1, 2, 3}의 인덱스에 위치한 값의 합이다.
lst[0]은 {0}의 인덱스에 위치한 값의 합이다.
{0, 1, 2, 3} - {0}  = {1, 2, 3} 즉 1~3까지의 합이다(차집합 느낌으로 생각하세요)
이제 이런식으로 예제를 설명해 보겠습니다.

5 3
5 4 3 2 1
1 3
2 4
5 5

1 3 : lst[3] - lst[1-1] : {0, 1, 2, 3} - {0} = {1, 2, 3}
2 4 : lst[4] - lst[2-1] : {0, 1, 2, 3, 4} - {0, 1} = {2, 3, 4}
5 5 : lst[5] - lst[5-1] : {0, 1, 2, 3, 4, 5} - {0, 1, 2, 3, 4} = {5}
이런식으로 이해하시면 됩니다.

??? : 어떄요 참 쉽죠?
'''
from sys import stdin
input = stdin.readline

lst = [0]
n, m = map(int, input().split())
for i in list(map(int ,input().split())): lst.append(lst[-1] + i)
for _ in range(m):
    i, j = map(int ,input().split())
    print(lst[j] - lst[i-1])