'''
res :   정답을 저장할 곳
s :     입력된 식(마지막에 "e"를 더한이유는 식의 마지막을 알리기 위해서 더함
is_in : 현재 괄호가 활성화된 상태인지를 알려줄 변수
num : ex)001, 0010등등 불필요한 위치에 0이있는 경우를 처리하기 위해서 만든 변수(정수로 바꾸면 불필요한 0은 사라짐)

우리는 주어진 식의 결과를 최소한을 만들 수 있게 괄호를 추가해야한다.
그렇다면 생각해볼 수 있는게
1.음수일 때는 무족건 괄호를 여는게 맞는가?
결론부터 말하면 맞다. 아래에 예시를 들어 설명하면
10 - 10 - 1 + 99
에 경우
10 -(10) -(1 + 99)로 만드는게 베스트다. 즉 괄호가 열린 상태에서 음수를 만났다면
기존 괄호를 닫고 새롭게 괄호를 열어서 시작하는게 가장 작은 값을 만드는 방법이다.
그리고 이 문제는 문자와 숫자를 복합적으로 다뤄야하므로 구현 난이도가 생각보다 있다.
그런데 다행이도 시간제한이 널널해서 잡기술을 사용해서 문제를 조금이나마 쉽게 풀 수 있었다.
(0001, 009, 010 같은 건 int()함수에 넣어서 처리하고 이를 다시 문자열로 바꿔서 쉽게 해결)

결론적으로 위 조건정도만 맞춰서 구현하면 쉽게 해결할 수 있다.
'''

res = ""
s = input()+'e'
is_in = False
num = ""
for i in s:

    if i=='e':#피연산자가 없는 경우
        res+=str(int(num))
        if is_in:  res+=")"#괄호가 활성화인 경우 괄호 닫기

    elif i=='-' and not is_in: #음수이면서 인 괄호 상태가 아닌경우
        res+=str(int(num))+'-('
        num=''
        is_in=True
        
    elif i=='-' and is_in: #인괄호인데 음수를 만난경우
        res+=str(int(num))+")"+"-("
        num = ''
        
    elif i=="+":
        res+=str(int(num))+"+"
        num = ''
        
    else: num+=i
print(int(eval(res)))