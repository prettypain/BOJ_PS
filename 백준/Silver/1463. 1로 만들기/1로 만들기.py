'''
dp-top down 방식으로 문제를 해결했다(위에서부터 내려오는 방식)
먼저 dp[n] = 0으로 한다 왜냐하면 n를 1로만드는데 사용되는 연산횟수를
출력할 예정이기에 n자체는 연산을 아무것도 하지 않은 값이다(주어진 연산에 한에서)
리스트의 인덱스 자체를 값으로 사용했고
주어진 연산([/3, /2, -1])을 인덱스 값에 적용해서
현재 위치에 올 수 있는 연산 즉
dp[i]번으로 올 수 있는 연산은 i를 나누기 3하기 전 즉 *3,
i를 /2하기전 즉 *2와 i를 -1하기전 즉 +1위치값중에서 가장 작은 값을
가져와서 내 위치에 +1 해서 저장한다.(단 i>2)

dp[n]은 0이니까 n-1부터 시작해서 1까지 위 연산을 반복하면서 내려간다.
그럼 결국 1까지 도달하는 가장적은 연산횟수를 알 수 있게된다.
마지막으로 dp[1]의 값을 출력!
'''
inf = 1111111
n = int(input())
dp = [inf]*(n*3+1)
dp[n] = 0
for i in range(n-1, 0, -1):
    dp[i] = min(dp[i*3], dp[i*2], dp[i+1]) + 1
print(dp[1])